<!DOCTYPE HTML>

<!--
These elements SHALL always appear in this order. These basic elements shared by all resources come first
in order to support consistent definitions for schema and UML derived code.
-->

[%settitle Workflow Description%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    [%file newheader%]
</head>

<body>
    [%file newnavbar%]

    <div class="col-9">

        <a name="root"> </a>
        <h2>Workflow Description</h2>
        <table class="cols">
            <tr>
                <td id="wg"><a _target="blank" href="[%wg fhir%]">[%wgt fhir%]</a> Work Group</td>
                <td id="fmm"><a href="resource.html#maturity">Maturity Level</a>: N/A</td>
                <td id="ballot"><a href="help.html#status">Ballot Status</a>: <a href="history.html#pubs">STU 3</a></td>
            </tr>
        </table>


        <p>
            Workflow is an essential part of healthcare - orders, care protocols, referrals are the drivers of most activity within in-patient settings and a great deal of activity in community care as well. FHIR is concerned with workflow when there's a need to
            share information about workflow state or relationships, when there's a need to coordinate or drive the execution of workflow across systems and when there's a need to define allowed actions, dependencies and conditions on behavior.
        </p>
        <p><b>Workflow state &amp; relationships</b></p>
        <p>
            FHIR does not need to be used for the execution of workflow. Orders, care plans, lab results, hospital admissions, claim payments and other records can all be shared using FHIR roesources without the process to actually solicit fulfillment of those orders
            or requesting payment of those claims being driven by a FHIR transaction. Interoperable support for workflow execution is actually a more advanced FHIR activity because it requires a higher degree of standardization. Rather than merely standardizing
            the data to exchange, interoperable workflow execution requires standardization of the processes, roles and activities of the different systems. However, even without using FHIR for workflow execution, there's still a need to standardize the
            data elements related to workflow: how does an event or a result point to the order that authorized it? How do parent steps and child steps get linked together? How does a care plan identify what protocol it's adhering to?
        </p>
        <p>
            FHIR defines three categories of resources that are involved in activities - <a href="#request">requests</a>, <a href="#event">events</a> and
            <a href="#definition">definitions</a>. Each of these different types has a "pattern" associated with it. Â Resources that fall into that type are encouraged to adhere to their respective pattern. These patterns provide standard elements that
            are typical for most resources of each type. Strict adherence is not required as work groups are expected to align with typical domain behavior and requirements as more authoritative than "desired" architectural patterns. In some cases, capabilities
            might be supported with extensions rather than core elements where a pattern capability is deemed to be "not common, but still relevant" for a given resource.
        </p>
        <p>
            A full description of the patterns and their interrelationships can be found in the <a href="#respatterns">Workflow Resource Patterns</a> section of this page.
        </p>
        <p><b>Workflow execution</b></p>
        <p>
            In addition to defining patterns for resources used in workflow processes, FHIR supports the execution of those processes as well. However, FHIR does not define a "one size fits all" solution for workflow architecture. FHIR supports a variety of interoperability
            paradigms and most of them (<a href="http.html">REST</a>,
            <a href="messaging.html">Messaging</a> and <a href="services.html">Services</a>) provide support for driving workflow execution. (The <a href="documents.html">Document</a> paradigm does not directly support driving behavior, though it can
            be combined with one of the other patterns to do so.) In addition, several of these paradigms allow multiple approaches to supporting workflow, depending on the context and needs of the workflow process.
        </p>
        <p>The <a href="#commpatterns">Workflow Execution and Communication Patterns</a> section of this page describes a number of options for workflow execution, summarizes their respective pros and cons and makes recommendations for the circumstances
            in which they might best be used.</p>
        <p><b>Workflow definition</b></p>
        <p>
            The definition of protocols, order sets, guidelines and other structures that define what sorts of activities should occur, what order they should occur on, what dependencies they have, in what circumstances they should start or end, etc. is handled by
            a pair of resources:
        </p>
        <ul>
            <li><a href="plandefinition.html">PlanDefinition</a> defines the interrelationships of steps and the rules around their execution</li>
            <li><a href="activitydefinition.html">ActivityDefinition</a> defines an activity to be performed as a single step</li>
        </ul>
        <p>
            The use of these two artifacts is documented TODO.
        </p>

        <a name="respatterns"> </a>
        <h3>Workflow Resource Patterns</h3>
        <p>Not all resources in FHIR are related to workflow - many are used to describe entities and roles (patients, medications, etc.) or infrastructure (structure definitions, value sets, etc.). However, a large proportion of the FHIR resources are devoted
            to the description of activities in one fashion or another and almost all of these fall into the realm of workflow - they describe things that can be done (definitions), are desired to be done (requests) or that have been done (events). The
            table below summarizes the list of workflow-relevant resources:</p>

        <a name="list"> </a>
        <h4>Workflow resources</h4>
        <table style="grid">
            <tbody>
                <tr>
                    <th>Requests</th>
                    <td colspan="3">Resources that ask for or express a desire/intention for something to be done</td>
                </tr>
                <tr>
                    <td>
                        <ul>
                            <li><a href="appointment.html">Appointment</a><sup><a href="#listnotes">*</a></sup></li>
                            <li><a href="careplan.html">CarePlan</a></li>
                            <li><a href="claim.html">Claim</a></li>
                            <li><a href="communicationrequest.html">CommunicationRequest</a></li>
                            <li><a href="devicerequest.html">DeviceRequest</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="diagnosticrequest.html">DiagnosticRequest</a></li>
                            <li><a href="eligibilityrequest.html">EligibilityRequest</a></li>
                            <li><a href="enrollmentrequest.html">EnrollmentRequest</a></li>
                            <li><a href="immunizationrecommendation.html">ImmunizationRecommendation</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="medicationrequest.html">MedicationRequest</a></li>
                            <li><a href="nutritionorder.html">NutritionOrder</a></li>
                            <li><a href="procedurerequest.html">ProcedureRequest</a></li>
                            <li><a href="processrequest.html">ProcessRequest</a><sup><a href="#listnotes">&#8224;</a></sup></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="referralrequest.html">ReferralRequest</a></li>
                            <li><a href="task.html">Task</a><sup><a href="#listnotes">&#8225;</a></sup></li>
                            <li><a href="supplyrequest.html">SupplyRequest</a></li>
                            <li><a href="visionprescription.html">VisionPrescription</a></li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Events</th>
                    <td colspan="3">Resources that express that something has been done and which can potentially be done as a result of a request</td>
                </tr>
                <tr>
                    <td>
                        <ul>
                            <li><a href="appointmentresponse.html">AppointmentResponse</a><sup><a href="#listnotes">*</a></sup></li>
                            <li><a href="claimresponse.html">ClaimResponse</a></li>
                            <li><a href="clinicalimpression.html">ClinicalImpression</a></li>
                            <li><a href="communication.html">Communication</a></li>
                            <li><a href="composition.html">Composition</a></li>
                            <li><a href="condition.html">Condition (aka Problem)</a></li>
                            <li><a href="consent.html">Consent</a></li>
                            <li><a href="contract.html">Contract</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="coverage.html">Coverage</a></li>
                            <li><a href="deviceusestatement.html">DeviceUseStatement</a></li>
                            <li><a href="diagnosticreport.html">DiagnosticReport</a></li>
                            <li><a href="eligibilityresponse.html">EligibilityResponse</a></li>
                            <li><a href="encounter.html">Encounter</a></li>
                            <li><a href="enrollmentresponse.html">EnrollmentResponse</a></li>
                            <li><a href="episodeofcare.html">EpisodeOfCare</a></li>
                            <li><a href="explanationofbenefit.html">ExplanationOfBenefit</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="familymemberhistory.html">FamilyMemberHistory</a></li>
                            <li><a href="guidanceresponse.html">GuidanceResponse</a></li>
                            <li><a href="imagingstudy.html">ImagingStudy</a></li>
                            <li><a href="immunization.html">Immunization</a></li>
                            <li><a href="measurereport.html">MeasureReport</a></li>
                            <li><a href="medicationadministration.html">MedicationAdministration</a></li>
                            <li><a href="medicationdispense.html">MedicationDispense</a></li>
                            <li><a href="medicationstatement.html">MedicationStatement</a></li>
                            <li><a href="observation.html">Observation</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="paymentnotice.html">PaymentNotice</a></li>
                            <li><a href="paymentreconciliation.html">PaymentReconciliation</a></li>
                            <li><a href="procedure.html">Procedure</a></li>
                            <li><a href="processresponse.html">ProcessResponse</a><sup><a href="#listnotes">&#8224;</a></sup></li>
                            <li><a href="questionnaireresponse.html">QuestionnaireResponse</a></li>
                            <li><a href="riskassessment.html">RiskAssessment</a></li>
                            <li><a href="supplydelivery.html">SupplyDelivery</a></li>
                            <li><a href="task.html">Task</a><sup><a href="#listnotes">&#8225;</a></sup></li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Definitions</th>
                    <td colspan="3">Resources that define something that can potentially happen in a patient and time-independent manner</td>
                </tr>
                <tr>
                    <td>
                        <ul>
                            <li><a href="activitydefinition.html">ActivityDefinition</a></li>
                            <li><a href="dataelement.html">DataElement</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="healthcareservice.html">HealthcareService</a></li>
                            <li><a href="measure.html">Measure</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="operationdefinition.html">OperationDefinition</a></li>
                            <li><a href="plandefinition.html">PlanDefinition</a></li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li><a href="questionnaire.html">Questionnaire</a></li>
                        </ul>
                    </td>
                </tr>
            </tbody>
        </table>

        <a name="listnotes"> </a>
        <table>
            <tbody>
                <tr>
                    <td><sup>*</sup></td>
                    <td>The <a href="appointment.html">Appointment</a> and <a href="appointmentresponse.html">AppointmentResponse</a> resources do not follow the same sort of request/response pattern as the other resources. Their design is based on iCal conventions,
                        so their model won't reflect the same alignment as most other resources. They are included here for completeness.</td>
                </tr>
                <tr>
                    <td><sup>&#8224;</sup></td>
                    <td><a href="processrequest.html">ProcessRequest</a> and <a href="processresponse.html">ProcessResponse</a> are candidates for retirement with their function subsumed by
                        <a href="task.html">Task</a></td>
                </tr>
                <tr>
                    <td><sup>&#8225;</sup></td>
                    <td>The <a href="task.html">Task</a> resource takes on characteristics of both "requests" and "events" and thus shares characteristics from both patterns</td>
                </tr>
            </tbody>
        </table>

        <p>
            Note that requests, events and definitions don't exist in a 1:1:1 relationship. Some requests and events have obvious pairings. For example, a
            <a href="supplyrequest.html">SupplyRequest</a> will generally always pair with a <a href="supplydelivery.html">SupplyDelivery</a>. The same goes for
            <a href="enrollmentrequest.html">EnrollmentRequest</a>/<a href="enrollmentresponse.html">EnrollmentResponse</a>, etc. On the other hand, for other resources there isn't a strict pairing. A <a href="referralrequest.html">ReferralRequest</a>            might be responded to by an <a href="encounter.html">Encounter</a>,
            <a href="diagnosticreport.html">DiagnosticReport</a>, <a href="procedure.html">Procedure</a>, <a href="riskassessment.html">RiskAssessment</a>, etc. Similarly, a <a href="procedure.html">Procedure</a> might be triggered by a <a href="diagnosticrequest.html">DiagnosticRequest</a>,
            <a href="procedurerequest.html">ProcedureRequest</a>, or <a href="referralrequest.html">ReferralRequest</a>. The set of common linkages should be asserted in their respective resources. The specific types of responses for a given request will
            be governed by the Request.code, any workflow definitions/protocols referenced and local convention.
        </p>

        <a name="relationships"> </a>
        <h4>Workflow Resource Relationships</h4>
        <p>
            These three patterns of resources have a standard set of relationships, both with themselves, as well as with each other.
        </p>
        <img width="624" height="421" src="workflow-relations.png" alt="Workflow relationships diagram showing Request, Event and Definition and their relationships to themselves and each other" />
        <p>
            Specifically:
        </p>
        <ul>
            <li>both requests and events can point to their respective definitions</li>
            <li>events and requests can point to the proposals, plans or orders they are based on</li>
            <li>events and definitions can be organized into parent-child relationships of parents and components</li>
            <li>definitions and requests can both replace prior versions of the same type of artifact</li>
        </ul>
        <p>
            This list of relationships is not exhaustive, but covers those that are "standardized" as part of the patterns. Further description and guidance on these relationships can be found in the <a href="request.html">Request</a>, <a href="event.html">Event</a>            and <a href="definition.html">Definition</a> logical models.
        </p>

        <a name="request"> </a>
        <h4>Request Resource Pattern</h4>
        <p>
            Requests are resources that represent the proposal, plan or order for an activity to occur. A <a href="request.html">Request pattern</a> defines the common elements typically present on all request resources.
        </p>
        <p>
            The amount of information needed for a Request to be actionable can vary by circumstance. Some request instances may not be "fully specified" - additional information from protocol, patient preference and/or professional decision-making may be necessary
            before the authorized action can occur. For example, a MedicationOrder might be specified without indicating a strength or route in situations where the pharmacy (or even nursing information) has the authority to determine those parameters.
            A VisionPrescription might not be actionable until frames have been chosen and the necessary measurements of the patient's face have been taken to allow the lenses to be positioned appropriately within the frames.
        </p>
        <p>
            All requests with an intent of "order" authorize something. Whether what is authorized is sufficient to be immediately actionable depends on who is fulfilling the order and the context in which the fulfillment request is made. The determination of whether
            a given "request" is actionable may be made by the systems involved or the humans being asked to act.
        </p>
        <p>
            As well, the existence of a "Request" instance doesn't necessarily imply that fufillment will be requested immediately - or even ever. The decision to request fulfillment may be delegated to the patient or to down-stream practitioners. Such fufilling
            practitioners may need to capture additional information prior to executing the fufillment.
        </p>

        <a name="event"> </a>
        <h4>Event Resource Pattern</h4>
        <p>
            Events are resources that represent the ongoing or completed execution of some activity or observation. For example, a clinical procedure, a financial transaction, the recording of a diagnosis, etc. An <a href="event.html">Event pattern</a>            defines the common elements typically present on all event resources.
        </p>

        <a name="definition"> </a>
        <h4>Definition Resource Pattern</h4>
        <p>
            Definitions are resources that represent activities that could be performed in a time and subject-independent manner such as a protocol, order set, clinical guideline, etc. A <a href="definition.html">Definition pattern</a> defines the common
            elements typically present on all event resources.
        </p>

        <a name="commpatterns"> </a>
        <h3>Workflow Execution and Communication Patterns</h3>
        <p>
            As described earlier, many FHIR resources can be used within workflows without using FHIR to manage the execution of the workflows. When we want to manage workflow execution with FHIR, there is a number of mechanisms available. In addition to managing
            workflow with FHIR, there are also cases where management of workflow execution is not necessary, and supporting workflow becomes simply the use of the <a href="#respatterns">resource paterns</a> in an ad-hoc fashion. In considering
            how best to interoperate around workflow with FHIR, there are a number of considerations:
        </p>
        <ul>
            <li>Is sharing of the state of the workflow necessary among the participants?</li>
            <li>Which paradigm do you want to use (REST, messaging or services)?</li>
            <li>Who owns/manages the various resources involved in the workflow (placer, filler, another participant)?</li>
            <li>Is there infrastructure in place to support polling, push notifications via subscriptions or both?</li>
            <li>Is there a need for confirmation that the desired performer agrees to act, or can that be presumed?</li>
            <li>Is there a need to negotiate whether/how the requested action will be performed?</li>
            <li>Can the requesting and performing system communicate directly? Are they able to post to each other's servers (if using REST)?</li>
            <li>Is there an ability/need to have a queue server to facilitate workflow execution?</li>
            <li>How many potential actors are involved?</li>
            <li>Will the workflow always be directed or is there a pool of potential performers who could choose to perform the requested action?</li>
        </ul>
        <p>
            The answers to these (and other) questions will guide the selection of communication patterns to be used for a specific interoperability use case. It is recommended that domain workgroups analyze the support for workflow execution within their domains
            and provide recommendations for an appropriate subset of patterns, with a discussion on where and how to use them. Implementation guides, by their nature, should prescribe which patterns to use for workflow execution management.
        </p>
        <a name="commpatternsoverview"> </a>
        <h4>Communication Patterns Conventions and Overview</h4>
        <p>
            This section highlights some of the more common patterns and identifies their characteristics and limitations and provides recommendations on when each approach may be most useful or relevant. Please note that this list of patterns is not exhaustive.
            Patterns can be combined in various ways and there are likely some possibilities we haven't thought about yet (feel free to submit additional patterns using the 'submit a change' link at the bottom of the page). As well, the recommendations
            given here are just that - recommendations. Implementers are free to choose which patterns they wish to support. Because of this, tight interoperability around workflow execution (as with any other tight interoperability using FHIR) will depend
            on communicating participants doing some up-front negotiation around how they plan to support workflow execution or all communicating partners will need to adhere to an implementation guide that sets out clear interoperability expectations.
        </p>
        <p>
            Prior to reviewing this list of options, readers are encouraged to be familiar with the following pages and resources: <a href="http.html">REST</a>,
            <a href="messaging.html">messaging</a>, <a href="operations.html">operations</a>, <a href="services.html">services</a> and the <a href="subscription.html">Subscription</a> resource.
        </p>
        <p>
            The scenarios used to illusttrate the patterns below make use of a few conventions:
        </p>
        <ul>
            <li>The focus here is on a "request" and the actioning of that request. Almost all workflows can be broken down to a sequence of these steps, though the responsibilities of the different parties may shift for each interaction and there can be
                more than two parties involved in the overall workflow</li>
            <li>The request could be as simple as "please look at this information" and the response could be as simple as an implicit "it's been looked at" or the request could be for some more involved action that may include reporting back multiple interim
                and final steps</li>
            <li>The requester is referred to as the "placer" and the performer is referred to as the "filler", which are often seen as order-specific terms. However, in this context, the terms hold whether the request is expressed as a proposal, plan or full-blown
                order
            </li>
            <li>Each of the patterns defines the set of steps involved in processing the request, lists some of the benefits and limitations associated with the approach, provides a scenario to illutrate the use of the pattern, and then makes recommendations
                about when the pattern is most appropriate</li>
            <li>The descriptions of these patterns focuses on the notion of requesting fulfillment of a request. However most of these patterns are also applicable to requests for status change, requests for information, etc. If a pattern is limited in the
                types of execution it can trigger, this will be noted in the "limitations" section.</li>
        </ul>

        <p>
            One of the key distinguishing characteristics in the patterns below is whether the pattern supports the tracking of the wrokflow's state by both the placer and the filler. The workflow state is represented by the <a href="task.html">Task</a>            resource, as hown the the state diagram, which is alo presented here:
        </p>
        <img src="task-state-machine.svg" alt="Diagram showing typical state machine for the Task resource" />
        <p>
            The patterns that facilitate the execution of workflow using the <a href="task.html">Task</a> resource are grouped in the Workflow Execution Patterns section. The patterns where no Task resource is used are grouped in the Ad-hoc Workflow Patterns
            section. The list of patterns is as follows:
        </p>
        <table>
            <tbody>
                <tr>
                    <th>
                        Workflow Execution Patterns
                    </th>
                </tr>
                <tr>
                    <td>
                        <a href="#optiona">Option A: Creation of Task on placer's system</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optionb">Option B: POST of Task on fulfiller's system</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optionc">Option C: POST of Task to a workflow broker</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optiond">Option D: Messaging Task from placer to fulfiller</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optione">Option E: Service request referencing Task from placer to fullfiller</a>
                    </td>
                </tr>
                <tr>
                    <th>
                        Ad-hoc Workflow Patterns
                    </th>
                </tr>
                <tr>
                    <td>
                        <a href="#optionf">Option F: Simple RESTful POST or PUT</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optiong">Option G: Direct POST of request to fulfiller's system</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optionh">Option H: POST of request to placer/queue server system, receiver uses polling or subscription</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optioni">Option I: POST of "request" resource for filler system, response via Task</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optionj">Option J: Messaging request from placer to filler &amp; acknowledgment</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#optionj">Option K: Services request from placer to filler &amp; acknowledgment</a>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="#additional">Additional Scenarios</a>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>
            TODO: Insert Jose's decision tree here?
        </p>
        <a name="optiona"> </a>
        <h4>Option A: Creation of Task on placer's system</h4>
        <img alt="Diagram showing creation of Task on placer system workflow" src="workflow-optiona.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer creates the request in its own system via POST or an internal action, or POSTs it to a queue server system</li>
            <li>Placer creates a Task resource in its own system via POST or an internal action, or POSTs it to a queue server system, pointing to the request resource and seeking fulfillment.<br/> The Task may have a specified performer, in which case step
                3 is expected to be done by that performer.<br/> If the Task does not have a specified "performer" (although may have performer type), then this is a case of an "open" task, where any number of fulfillers may attempt to "claim" the task.
                Who succeeds is determined by local policies and procedures.</li>
            <li>Fulfiller system uses either polling or pub/sub to become aware of the existence of the task
                <ol style="list-style:lower-alpha">
                    <li>A common case may be the conveyance of the Task id to a fullfiller by other means. For example, a lab test is ordered, and the patient takes a requisition to the lab of his choice. The requisition contains the Task id (as a bar code,
                        or stored in the patient's healthcre smart card), and the lab system can execute a direct GET for the Task, thus eliminating the need for subscription or polliing.</li>
                </ol>
            </li>
            <li>Fulfiller system queries to retrieve the referenced request, and updates the Task to indicate "acceptance" and agreement to fulfill </li>
            <li>Fulfiller may update the Task to indicate interim progress notes</li>
            <li>Placer is aware of the acceptance of and changes to the Task either through the ownership of the resource, or using polling or a subscription to a queue server system to determine the same</li>
            <li>Fulfiller creates an event resource in its own system via POST or internal action, or POSTs it to a queue server system</li>
            <li>Fulfiller PUTs an update to the Task resource to change its status to completed and to point to the event resource</li>
            <li>Placer is aware of the completion of the Task either through the ownership of the resource, or via polling or subscription to a queue server system, and retrieves the referenced event resource</li>
            <li>Placer updates the request resource to indicate completion via PUT or an internal action, or PUTs the update to a queue server system</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Uses the FHIR REST API for managing the workflow</li>
            <li>Both placer and fulfiller can track the state of the workflow</li>
            <li>Can use this approach for request other than just fulfillment (e.g. to request status change or other updates)</li>
            <li>There's an ability to negotiate fulfillment - i.e. the ability to say "no"</li>
            <li>Explicit acknowledgement that filler has received and agreed to act on the request</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Additional complexity of using Task</li>
            <li>Additional complexity of setting up and maintaining a subscription or polling infrastructure</li>
            <li>Placer and fulfiller must have a FHIR server, and placer's FHIR server pust allow "write" updates to the Task resource</li>
            <li>
                <p>Placer and filler may need to be able to communicate directly (i.e. know each other's respective endpoints)</p>
                <ul>
                    <li>This could become unmanageable if there are a large (or dynamic) number of placers and fillers that need to communicate</li>
                    <li>Placer and fulfiller must know where to subscribe for content - this could be a large number of systems</li>
                    <li>May not apply if there's a queue server</li>
                </ul>
            </li>
        </ul>
        <h5>Usage Recommendations</h5>
        <ul>
            <li>When following the state of the workflow is important
                <ul>
                    <li>When there is a need to know that a fulfiller has accepted to perform the request</li>
                    <li>When there is a need to be able to change the performance of the request</li>
                    <li>When there are multiple steps in fulfilling the request</li>
                </ul>
            </li>
            <li>When requests are not (always) directed to a specific filler</li>
            <li>When the placer needs to manage the Task resource</li>
        </ul>

        <h5>Usage examples</h5>
        <p><b>Lab order to known performer</b></p>
        <p>A provider orders a bilirubin test for a patient, to be done at the provider's facility lab....</p>
        <p><b>"Open" lab order</b></p>
        <p>
            A patient is scheduled for their physical, and the provider sends her a secure message to have a fasting blood test performed before the office visit. The message has a link to a requisition, and a list of possible lab loacations where the test can be
            done. The patient chooses a lab location near her place of employment, and a test is scheduled. The lab gets the requisition from the patient, and using the information on how to retrieve the Task from the provider's system, claims the test
            to be performed...
        </p>

        <a name="optionb"> </a>
        <h4>Option B: POST of Task on fulfiller's system</h4>
        <img alt="Diagram showing POST of Task to filler system workflow" src="workflow-optionb.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer creates the request in its own system via POST or an internal action, or POSTs it to a queue server system</li>
            <li>Placer POSTs a Task resource to the filler system, pointing to the request resource and seeking fulfillment</li>
            <li>Fulfiller system GETs the referenced request</li>
            <li>Fulfiller updates the Task to indicate acceptance of the task</li>
            <li>Placer either polls the Task to note acceptance or uses a subscription to determine the same</li>
            <li>Fulfiller may further update the Task to reflect the progeess made. Using the same method as in step 5, the placer becomes aware of these updates</li>
            <li>Fulfiller creates an event resource in its own system via POST or an internal action, or POSTs it to a queue server system </li>
            <li>Fulfiller Updates the Task resource to change its status to completed and to point to the event resource</li>
            <li>Placer either polls the Task to note completion and changes or uses a subscription to determine the same</li>
            <li>Placer system queries to retrieve the referenced event resource</li>
            <li>Placer updates the request resource to indicate completion via PUT or an internal action, or PUTs the update to a queue server system</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Uses the FHIR REST API for managing the workflow</li>
            <li>Subscription/polling is targeted to a specific resource instance - much simpler than general subscription/polling infrastructure</li>
            <li>Both placer and fulfiller can track the state of the workflow</li>
            <li>Can use this approach for request other than just when requesting fulfillment (e.g. to request status change or other updates)</li>
            <li>There's an ability to negotiate fulfillment - i.e. the ability to say "no"</li>
            <li>Explicit acknowledgement that filler has received and agreed to act on the request</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Additional complexity of using Task</li>
            <li>Additional complexity of using subscription or polling</li>
            <li>Placer and fulfiller must have a FHIR server, and fulfiller's FHIR server must allow "write" creation of the Task resource by the placer</li>
            <li>
                Placer and filler may need to be able to communicate directly (i.e. know each other's respective endpoints)
                <ul>
                    <li>This could become unmanageable if there are a large (or dynamic) number of placers and fillers that need to communicate</li>
                    <li>May not apply if there's a queue server</li>
                </ul>
            </li>
            <li>Placer may not know immediately when filler system has retrieved the request</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <ul>
            <li>When following the state of the workflow is important
                <ul>
                    <li>When there is a need to know that a fulfiller has accepted to perform the request</li>
                    <li>When there is a need to be able to change the status of the workflow by either the placer or the fulfiller</li>
                    <li>When there are multiple steps in fulfilling the request</li>
                </ul>
            </li>
            <li>When the fulfiller needs to manage the Task resource</li>
        </ul>
        <h5>Usage Examples</h5>
        <p><b>Outpatient prescription</b></p>
        <p>
            A patient is suffering from a poison ivy rash, and he is prescribed a steroid medication to manage the reaction. The provider asks the patient for his preferred pharmacy and creates the Task at the specified pharmacy's system. The patient is running late
            and by the time he arrives at the pharmacy, it is closed. He calls the clinic where the provider practices, and requests that the pharmacy where the order is to be fulfilled is changed to one that is open around the clock. The staff at the
            clinic cancels the Task at the original pharmacy, and creeates a new Task at the requested new one. By the time the patient arrives at the new pharmacy, the medicatin is ready for pickup. Once the request is fulfilled, the clinic receives
            the notification that the Task is complete, and the prescription is also marked as complete.
        </p>

        <a name="optionc"> </a>
        <h4>Option C: POST of Task to a workflow broker </h4>
        <p>
            <i>TODO: Still needs review and update</i>
        </p>
        <img alt="Diagram showing workflow broker workflow" src="workflow-optionc.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer POSTs the request to its own system or to a queue server system</li>
            <li>Broker detects that new un-assigned request (without a Task yet created and falling within the scope of the Broker to ensure fulfillment) via polling or subscription</li>
            <li>Broker POSTs a Task resource to its own system or a queue server system, pointing to the request resource and seeking fulfillment from a specific filler<br/> Task does not have a specified "performer" (but may have performer type)</li>
            <li>If the Task is rejected by one potential recipient, the broker may create a new task to seek fulfillment from others</li>
            <li>Continue as per <a href="#optiong">Option G</a></li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Offloads responsibility for seeking fulfillment from the placer system, but more actively solicits fulfillment than a simple "post the task and see who takes it". Also allows prioritized assignment of tasks (i.e. some fillers may be preferred
                over others)</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Requires a broker to exist</li>
            <li>Broker must know all available fillers and their capabilities to allow appropriate assignment</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            Appropriate in environments that have a workflow engine that takes on responsibility for ensuring fulfillment
        </p>
        <h5>Usage Examples</h5>
        <p>
        </p>

        <a name="optiond"> </a>
        <h4>Option D: Messaging Task from placer to fulfiller</h4>
        <p>
            <i>TODO: needs more details</i>
        </p>
        <h5>Steps</h5>
        <ol>
            <li>Placer sends message to filler with a MessageHeader, where the "data" element points to the Taks resource, also contained in the message. The massage may or may not contain any other relevant resources (e.g the actual request resource), or
                an "event" code saying "please fulfill"</li>
            <li>Filler system sends a response containing the same Task resource, indicating receipt of the message and, optionally an indication of their intention to fulfill the request</li>
            <li>Filler system may send incremental messages to the placer showing progress (e.g. specimen collected, preliminary results, final results) by including an updated Task resource</li>
            <li>Placer system may also send messages to the fulfiller conatining the Task resource and updatingh the state of the workflow</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Reduced number of communications</li>
            <li>All relevant data can be sent in one package</li>
            <li>Responses can be asynchronous and content may be routed</li>
            <li>There's an ability to negotiate fulfillment - i.e. the ability to say "no"</li>
            <li>Can request things other than just fulfillment (e.g. please suspend)</li>
            <li>Explicit acknowledgement that filler has received and agreed to act on the request (though no need for the placer to check)</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Messaging is "heavy"</li>
            <li>Need to negotiate what allowed responses are and what data can be present in request and response messages</li>
            <li>Additional complexity of using Task</li>
            <li>Need message delivery infrastructure in place</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            Appropriate when existing messaging infrastructure can be used (e.g. HL7 over HTTP, v2 LTP, MLTP, WSI Web Services, Direct, VISA, REST, etc.), and a need to stay consistent with that architecture.
        </p>
        <h5>Usage examples</h5>
        <p>
        </p>
        <a name="optione"> </a>
        <h4>Option E: Service request referencing Task from placer to fullfiller</h4>
        <p>
            <i>TODO: This scenario needs work - there's not a lot of experience using FHIR services to manage the fulfillment process</i>
        </p>
        <h5>Steps</h5>
        <ol>
            <li>Placer creates a request resource on their own system or a queue server</li>
            <li>Placer may create a Task resource on their own system or a queue server</li>
            <li>Placer invokes a service on the filler system saying "please fulfill this order", including the content or a reference to the request resource and any other relevant data
            </li>
            <li>Filler system responds (synchronously if using HTTP, but may be asynchronous if using SOAP or other transport mechanisms) with conformation of receipt and, optionally indication of intention to fulfill and/or results</li>
            <li></li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>???</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>???</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            TBD
        </p>
        <h5>Usage examples</h5>
        <p>
        </p>

        <a name="optionf"> </a>
        <h4>Option F: Simple RESTful POST or PUT</h4>
        <h5>Steps</h5>
        <ol>
            <li>The placer makes a RESTful call to <a href="http.html#create">create</a> or <a href="http.html#update">update</a> a record or a POST to invoke an
                <a href="operations.html#executing">operation</a> over HTTP</li>
            <li>The receiver responds with a 2xx HTTP response indicating whether the request was successfully processed or not and, if appropriate, provides the response to the request in the payload of the HTTP response</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Simplest of all the possible workflow architectures</li>
            <li>Placer knows whether the request was accepted or not and knows when the task has been done</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Only works for automated execution where the decision to perform the request and the execution of the request can be done synchronously within the HTTP timeout period (generally on the order of 10s of seconds).</li>
            <li>Requires that the placer have authority to post directly to the placer's system</li>
            <li>Requires that the "request" be expressible as a simple creation, update or operation invocation</li>
            <li>Only works for "fulfillment" requests for Request resources - can't handle request for state changes or information</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            This is by far the most common pattern in FHIR for simple changes as it requires the least overhead. However, it covers only automated responses, and does not support any ctual workflows of more than one step. If human processing is involved in the request
            execution, then this approach won't suffice. This approach is listed here to make sure that implementers consider whether they can make this one work first before falling back to one of the more sophisticated patterns.
        </p>
        <h5>Usage Examples</h5>
        <p><i>Can't think of any</i></p>

        <a name="optiong"> </a>
        <h4>Option G: Direct POST of request to fulfiller's system</h4>
        <img alt="Diagram showing direct POST of request to fulfiller's system workflow" src="workflow-optiong.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer system invokes a <a href="http.html#create">create</a> by POSTing a 'request' resource (e.g. <a href="medicationrequest.html">MedicationRequest</a>,
                <a href="diagnosticrequest.html">DiagnosticRequest</a>, <a href="referralrequest.html">ReferralRequest</a>, etc.) to the appropriate RESTful resource endpoint (e.g. [base]/MedicationRequest) on the filler system and places an <a href="codesystem-common-tags.html#common-tags-actionable">actionable</a>
                <a href="resource.html#simple-tags">tag</a> on the resource that indicates the request is intended to be acted upon, not merely stored.</li>
            <li>The filler synchronously responds with a "201" indicating that that they have received and stored (created) the resource on their system</li>
            <li>At some later point, the filler POSTs an 'event' resource (e.g. <a href="medicationdispense.html">MedicationDispense</a>,
                <a href="diagnosticreport.html">DiagosticReport</a>, <a href="encounter.html">Encounter</a>, etc.) to the appropriate resource endpoint on the placer system, including a <code>basedOn</code> link to the 'request' resource that the action
                was performed in fulfillment of.</li>
            <li>The placer system synchronously responds with a "201" indicating they've received and store (created) the resource on their system</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Lowest amount of overhead. No need for <a href="task.html">Task</a>. No need for polling or subscriptions</li>
            <li>Explicit acknowledgement that filler has received the request</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Can only use when requesting fulfillment (can't use to request status change or other updates)</li>
            <li>Placer and filler must be able to communicate directly (i.e. know each other's respective endpoints) and must each have a FHIR server and must have "write" permissions to each other's servers. This could become unmanageable if there are a
                large (or dynamic) number of placers and fillers that need to communicate</li>
            <li>No indication of agreement to act on the request</li>
            <li>There's no ability to negotiate fulfillment - no ability to say "no"</li>
            <li>This completely reverses the usual provenance of resources, as the request only exists on the fulfiller's system, and the event only exists on the placer's system. This greatly limits the use of these resources for any other purpose.</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            Use this approach when there's no ability to have queue servers and no support/need for complexity of Task, polling or pub/sub (and no need for negotiation or the ability for the filler to say "no"). This is a pseudo-messaging architecture that doesn't
            actually use messaging architecture.
        </p>
        <h5>Usage Examples</h5>
        <p>
        </p>

        <a name="optionh"> </a>
        <h4>Option H: POST of request to placer/queue server system, receiver uses polling or subscribtion</h4>
        <img alt="Diagram showing POST of request to placer/queue server system, receiver uses polling workflow" src="workflow-optionh.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer system creates a 'request' resource (e.g. MedicationRequest, DiagnosticOrder, ReferralRequest, etc.) by a system action or a POST on either its own system or a third party queue server system and places an "actionable" tag on the resource
                that indicates the request is inteneded to be acted upon. The request explicitly identifies the intended fullfiller</li>
            <li>The filler system uses polling (or a subscription) at the placer or queue server system to see if there are any "new" requests that: are tagged as "actionable", have the filler identified as the intended performer, and are a type of request
                "of interest" to the filler.</li>
            <li>At some later point, the filler creates an 'event' resource (e.g. MedicationDispense, DiagosticReport, Encounter, etc.) via a system action, or a POST on either its own system, the same queue server as the request was placed on, or some alternate
                queue server, including a link to the 'request' resource that the action was performed in fulfillment of</li>
            <li>The placer system uses polling (or a subscription) to the filler or queue server system to see if there are any "new" events that are tied to any outstanding requests the placer has initiated</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Placer and fulfiller don't have to communicate directly (can act through queue server). This can reduce the number of point-to-point interfaces that need to be supported</li>
            <li>Preserves the conventional management and ownership of the request and event at the placer and fulfiller's systems respectively</li>
            <li>No need for Task</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Can only use when requesting fulfillment (can't use to request status change or other updates)</li>
            <li>Additional complexity of using subscription or polling</li>
            <li>Polling by the placer for "anything related to these 500 open orders" could be onerous, especially if some orders never get closed.</li>
            <li>Placer and fulfiller must know where to poll or subscribe for content - this could be a large number of systems</li>
            <li>No indication of agreement to act on the request</li>
            <li>There's no ability to negotiate fulfillment - no ability to say "no"</li>
            <li>Placer may not know when (or if) filler system has retrieved the request</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            This pattern could be used when there's no support/need for complexity of Task, usually for simple two step wrkflows. This is a more typically RESTful approach where data resides on the server "owned" by the data creator and is accessed by other systems.
        </p>
        <h5>Usage Examples</h5>

        <a name="optioni"> </a>
        <h4>Option I: POST of "request" resource for filler system, response via Task</h4>
        <p>
            <i>TODO: needs review, likely to be presented as a variation to option C</i>
        </p>
        <img alt="Diagram showing POST of &quot;request&quot; resource for filler system, response via Task workflow" src="workflow-optioni.png" />
        <h5>Steps</h5>
        <ol>
            <li>Placer system invokes a "create" action by POSTing a 'request' resource (e.g. MedicationRequest, DiagnosticOrder, ReferralRequest, etc.) to the appropriate RESTful resource endpoint (e.g. [base]/MedicationRequest) on the filler, placer or
                queue server system and sets a "tag" on the resource that indicates the request is "actionable"</li>
            <li>Filler POSTs a Task resource to its own system or a queue server system, pointing to the request resource and indicating intent to fulfill or refusal to fulfill</li>
            <li>Placer system uses either polling or pub/sub to become aware of the existence of the task and fulfillment intent</li>
            <li>Fulfiller may update the Task to indicate interim progress notes</li>
            <li>Placer either polls the Task to note acceptance and changes or uses a subscription to determine the same</li>
            <li>Fulfiller POSTs an event resource to its own system or to a queue server system</li>
            <li>Fulfiller Updates the Task resource to change its status to completed and to point to the event resource</li>
            <li>Placer system becomes aware of the update via polling or subscription</li>
            <li>Placer system retrieves the event</li>
            <li>Placer system marks the request as "complete"</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>There's an ability to negotiate fulfillment - i.e. the ability to say "no"</li>
            <li>Explicit acknowledgement that filler has received and agreed to act on the request (though no need for the placer to check)</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Can only use when requesting fulfillment (can't use to request status change or other updates)</li>
            <li>Additional complexity of setting up and maintaining a subscription or polling infrastructure</li>
            <li>Additional complexity of using Task</li>
            <li>Placer and filler may need to be able to communicate directly (i.e. know each other's respective endpoints) and have a FHIR server and have "write" permissions to each other's servers (if no queue server is used)</li>
            <li>Placer and fulfiller must know where to subscribe for content - this could be a large number of systems</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            Use this when the filler needs to have complete ownership over the task and there's no ability for both placer &amp; filler to manipulate tasks on a common server
        </p>

        <a name="optionj"> </a>
        <h4>Option J: Messaging request from placer to filler &amp; acknowledgment</h4>
        <p>
            <i>TODO: needs review and update</i>
        </p>
        <h5>Steps</h5>
        <ol>
            <li>Placer sends message to filler system including Request resource (and other relevant resources) along with a MessageHeader with an "event" code saying "please fulfill" and "data" element pointing to the Request resource as the item to fulfill.
                Message could potentially use Task instead of MessageHeader.event to convey desired action (ongoing discussion)</li>
            <li>Filler system sends a response indicating receipt of the message and, optionally an indication of their intention to fulfill the request</li>
            <li>Filler system may send incremental messages to the placer showing progress (e.g. specimen collected, preliminary results, final results)</li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>Reduced number of communications</li>
            <li>All relevant data sent in one package</li>
            <li>Responses can be asynchronous and content may routed</li>
            <li>There's an ability to negotiate fulfillment - i.e. the ability to say "no"</li>
            <li>Can request things other than just fulfillment (e.g. please suspend)</li>
            <li>Explicit acknowledgement that filler has received and agreed to act on the request (though no need for the placer to check)</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>Messaging is "heavy"</li>
            <li>Need to negotiate what allowed responses are and what data can be present in request and response messages</li>
            <li>Additional complexity of setting up and maintaining a subscription or polling infrastructure</li>
            <li>Additional complexity of using Task</li>
            <li>Need message delivery infrastructure in place</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            Existing messaging infrastructure (e.g. v2 LTP, MLTP, WSI Web Services, Direct, VISA, REST, etc.) and a need to stay consistent with that architecture
        </p>

        <a name="optionk"> </a>
        <h4>Option K: Services request from placer to filler &amp; acknowledgment</h4>
        <p>
            <i>TODO: Needs review, update and more work - there's not a lot of experience using FHIR services to manage the fulfillment process</i>
        </p>
        <h5>Steps</h5>
        <ol>
            <li>Placer may create and store a Request resource on their own system or a queue server.</li>
            <li>Placer invokes a service on the filler system saying "please fulfill this order", including the content or a reference to the request resource and any other relevant data
            </li>
            <li>Filler system responds (synchronously if using HTTP, but may be asynchronous if using SOAP or other transport mechanisms) with conformation of receipt and, optionally indication of intention to fulfill and/or results</li>
            <li></li>
        </ol>
        <h5>Benefits</h5>
        <ul>
            <li>???</li>
        </ul>
        <h5>Limitations</h5>
        <ul>
            <li>???</li>
        </ul>
        <h5>Usage Recommendations</h5>
        <p>
            TBD
        </p>

        <a name="additional"> </a>
        <h4>Additional Scenarios</h4>
        <p>
            <i>TODO: needs review and udate. Posibly add options about usiing messaging and/or services instead of polling/subscription in above scenarios</i>
        </p>
        <h5>Querying the status of a workflow using REST</h5>
        <ol>
            <li>Placer sends query for Task(s) that have a focus of the request of interest to a system (placer system, queue server or filler) that holds tasks related to their request.</li>
            <li>System returns a query response showing all related tasks (typically just one). Task shows current status.</li>
        </ol>

        <h5>Querying the status of a workflow using services</h5>
        <ol>
            <li>Placer invokes a "what's the status of this order" service, passing the request business identifier or URL of the request</li>
            <li>Services responds with a Task showing the current state of the fulfillment of the request</li>
        </ol>

        <h5>Cancellation of a Task using REST - placer owns</h5>
        <ol>
            <li>Placer sends an update to the Task setting the status to "cancelled"</li>
            <li>Filler receives notification of the update (because the task is on their system or because they poll it or are subscribed to it) and ceases work if they are able</li>
        </ol>

        <h5>Cancellation of a Task using REST - filler owns</h5>
        <ol>
            <li>Placer creates a new task requesting cancellation of the original fulfillment task<br/> Fulfillment of the "cancellation task" can be requested using any of the mechanisms above</li>
            <li>Filler decides whether they are able to cancel the task and update the "cancellation" task to indicate either cancellation is complete or has been refused</li>
        </ol>

        <a name="issues"> </a>
        <h3>Open Issues</h3>
        <blockquote class="dstu-note">
            <p>
                <b>STU Notes:</b>
            </p>
            <ul>
                <li>It is possible to replace some portions of the <a href="messageheader.html">MessageHeader</a> with a reference to the <a href="task.html">Task</a> resource. Doing so would mean consistency in how asynchronous requests are represented using
                    REST and messaging. However, it introduces an additional layer of complexity and formality into the messaging paradigm that may be unwelcome, particularly for those systems that do not currently foresee a need to support both RESTful
                    and messaging invocations of workflow</li>
                <li>The <a href="operationdefinition.html">OperationDefinition</a> resource could be used to define types of tasks and the sets of parameters that are allowed to go with them. Is this an appropriate use of the OperationDefinition resource?</li>
                <li>The <a href="supplyrequest.html">SupplyRequest</a>, <a href="devicerequest.html">DeviceRequest</a> and <a href="visionprescription.html">VisionPrescription</a> resources have a significant degree of overlap. Should they remain distinct
                    resources?
                </li>
            </ul>
        </blockquote>

    </div>

    [%file newfooter%]
</body>

</html>